schema {
  query: Query
  mutation: Mutation
  subscription: Subscription
}

"""
The purpose of the `cost` directive is to define a `weight` for GraphQL types, fields, and arguments. Static analysis can use these weights when calculating the overall cost of a query or response.
"""
directive @cost(
  """
  The `weight` argument defines what value to add to the overall cost for every appearance, or possible appearance, of a type, field, argument, etc.
  """
  weight: String!
) on ARGUMENT_DEFINITION | ENUM | FIELD_DEFINITION | INPUT_FIELD_DEFINITION | OBJECT | SCALAR

"""
The purpose of the `@listSize` directive is to either inform the static analysis about the size of returned lists (if that information is statically available), or to point the analysis to where to find that information.
"""
directive @listSize(
  """
  The `assumedSize` argument can be used to statically define the maximum length of a list returned by a field.
  """
  assumedSize: Int
  """
  The `requireOneSlicingArgument` argument can be used to inform the static analysis that it should expect that exactly one of the defined slicing arguments is present in a query. If that is not the case (i.e., if none or multiple slicing arguments are present), the static analysis may throw an error.
  """
  requireOneSlicingArgument: Boolean! = true
  """
  The `sizedFields` argument can be used to define that the value of the `assumedSize` argument or of a slicing argument does not affect the size of a list returned by a field itself, but that of a list returned by one of its sub-fields.
  """
  sizedFields: [String!]
  """
  The `slicingArgumentDefaultValue` argument can be used to define a default value for a slicing argument, which is used if the argument is not present in a query.
  """
  slicingArgumentDefaultValue: Int
  """
  The `slicingArguments` argument can be used to define which of the field's arguments with numeric type are slicing arguments, so that their value determines the size of the list returned by that field. It may specify a list of multiple slicing arguments.
  """
  slicingArguments: [String!]
) on FIELD_DEFINITION

union AddAddressToCustomerError = ApplicationError

input AddAddressToCustomerInput {
  address: CreateAddressInput!
  customerId: ID!
}

type AddAddressToCustomerPayload {
  customer: Customer
  errors: [AddAddressToCustomerError!]
}

union AddAddressToSupplierError = ApplicationError

input AddAddressToSupplierInput {
  address: CreateAddressInput!
  supplierId: ID!
}

type AddAddressToSupplierPayload {
  errors: [AddAddressToSupplierError!]
  supplier: Supplier
}

type Address {
  city: String
  country: Country
  dateTimeRemoved: DateTime
  id: UUID!
  number: String
  removed: Boolean!
  state: String
  street: String
  zipCode: String
}

input AddressSortInput {
  city: SortEnumType
  country: CountrySortInput
  dateTimeRemoved: SortEnumType
  id: SortEnumType
  number: SortEnumType
  removed: SortEnumType
  state: SortEnumType
  street: SortEnumType
  zipCode: SortEnumType
}

type ApplicationError implements Error {
  code: String!
  description: String!
  type: ErrorType!
}

type Article implements Node {
  code: String!
  description: String
  discontinued: Boolean!
  id: ID!
  name: String!
  price: Decimal!
  sellingUnit: Decimal!
  suppliers(
    """Returns the elements in the list that come after the specified cursor."""
    after: String
    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String
    """Returns the first _n_ elements from the list."""
    first: Int
    """Returns the last _n_ elements from the list."""
    last: Int
    order: [SupplierSortInput!]
    where: SupplierFilterInput
  ): SuppliersConnection
}

input ArticleFilterInput {
  and: [ArticleFilterInput!]
  code: StringOperationFilterInput
  description: StringOperationFilterInput
  discontinued: BooleanOperationFilterInput
  id: UuidOperationFilterInput
  name: StringOperationFilterInput
  or: [ArticleFilterInput!]
  price: DecimalOperationFilterInput
  sellingUnit: DecimalOperationFilterInput
}

input ArticleSortInput {
  code: SortEnumType
  description: SortEnumType
  discontinued: SortEnumType
  id: SortEnumType
  name: SortEnumType
  price: SortEnumType
  sellingUnit: SortEnumType
}

"""A connection to a list of items."""
type ArticlesConnection {
  """A list of edges."""
  edges: [ArticlesEdge!]
  """A flattened list of the nodes."""
  nodes: [Article!]
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """Identifies the total count of items in the connection."""
  totalCount: Int!
}

"""An edge in a connection."""
type ArticlesEdge {
  """A cursor for use in pagination."""
  cursor: String!
  """The item at the end of the edge."""
  node: Article!
}

input BooleanOperationFilterInput {
  eq: Boolean
  neq: Boolean
}

type Country {
  id: String!
  name: String!
}

input CountrySortInput {
  id: SortEnumType
  name: SortEnumType
}

input CreateAddressInput {
  city: String
  countryCode: String
  number: String
  state: String
  street: String
  zipCode: String
}

type Customer implements Node {
  active: Boolean!
  addresses(order: [AddressSortInput!]): [Address!]!
  code: String!
  dateTimeDeactivated: DateTime
  email: String
  id: ID!
  name: String!
  website: String
}

input CustomerFilterInput {
  active: BooleanOperationFilterInput
  and: [CustomerFilterInput!]
  code: StringOperationFilterInput
  dateTimeDeactivated: DateTimeOperationFilterInput
  email: StringOperationFilterInput
  id: UuidOperationFilterInput
  name: StringOperationFilterInput
  or: [CustomerFilterInput!]
  website: StringOperationFilterInput
}

input CustomerSortInput {
  active: SortEnumType
  code: SortEnumType
  dateTimeDeactivated: SortEnumType
  email: SortEnumType
  id: SortEnumType
  name: SortEnumType
  website: SortEnumType
}

"""A connection to a list of items."""
type CustomersConnection {
  """A list of edges."""
  edges: [CustomersEdge!]
  """A flattened list of the nodes."""
  nodes: [Customer!]
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """Identifies the total count of items in the connection."""
  totalCount: Int!
}

"""An edge in a connection."""
type CustomersEdge {
  """A cursor for use in pagination."""
  cursor: String!
  """The item at the end of the edge."""
  node: Customer!
}

"""The `DateTime` scalar represents an ISO-8601 compliant date time type."""
scalar DateTime

input DateTimeOperationFilterInput {
  eq: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime]
  lt: DateTime
  lte: DateTime
  neq: DateTime
  ngt: DateTime
  ngte: DateTime
  nin: [DateTime]
  nlt: DateTime
  nlte: DateTime
}

union DeactivateCustomerError = ApplicationError

input DeactivateCustomerInput {
  id: UUID!
}

type DeactivateCustomerPayload {
  boolean: Boolean
  errors: [DeactivateCustomerError!]
}

union DeactivateSupplierError = ApplicationError

input DeactivateSupplierInput {
  id: UUID!
}

type DeactivateSupplierPayload {
  boolean: Boolean
  errors: [DeactivateSupplierError!]
}

"""The `Decimal` scalar type represents a decimal floating-point number."""
scalar Decimal

input DecimalOperationFilterInput {
  eq: Decimal
  gt: Decimal
  gte: Decimal
  in: [Decimal]
  lt: Decimal
  lte: Decimal
  neq: Decimal
  ngt: Decimal
  ngte: Decimal
  nin: [Decimal]
  nlt: Decimal
  nlte: Decimal
}

union DiscontinueArticleError = ApplicationError

input DiscontinueArticleInput {
  input: IdInputOfGuidInput!
}

type DiscontinueArticlePayload {
  boolean: Boolean
  errors: [DiscontinueArticleError!]
}

interface Error {
  code: String!
  description: String!
  type: ErrorType!
}

enum ErrorType {
  CONFLICT
  FAILURE
  NOT_FOUND
  PROBLEM
  VALIDATION
}

input IdInputOfGuidInput {
  id: ID!
}

union LinkToSupplierError = ApplicationError

input LinkToSupplierInput {
  articleId: ID!
  supplierId: ID!
}

type LinkToSupplierPayload {
  article: Article
  errors: [LinkToSupplierError!]
}

type Mutation {
  addAddressToCustomer(input: AddAddressToCustomerInput!): AddAddressToCustomerPayload!
  addAddressToSupplier(input: AddAddressToSupplierInput!): AddAddressToSupplierPayload!
  deactivateCustomer(input: DeactivateCustomerInput!): DeactivateCustomerPayload!
  deactivateSupplier(input: DeactivateSupplierInput!): DeactivateSupplierPayload!
  discontinueArticle(input: DiscontinueArticleInput!): DiscontinueArticlePayload!
  linkToSupplier(input: LinkToSupplierInput!): LinkToSupplierPayload!
  registerArticle(input: RegisterArticleInput!): RegisterArticlePayload!
  registerCustomer(input: RegisterCustomerInput!): RegisterCustomerPayload!
  registerSupplier(input: RegisterSupplierInput!): RegisterSupplierPayload!
  removeAddressFromCustomer(input: RemoveAddressFromCustomerInput!): RemoveAddressFromCustomerPayload!
  removeAddressFromSupplier(input: RemoveAddressFromSupplierInput!): RemoveAddressFromSupplierPayload!
  unlinkFromSupplier(input: UnlinkFromSupplierInput!): UnlinkFromSupplierPayload!
  updateArticleDetails(input: UpdateArticleDetailsInput!): UpdateArticleDetailsPayload!
  updateCustomerAddress(input: UpdateCustomerAddressInput!): UpdateCustomerAddressPayload!
  updateCustomerDetails(input: UpdateCustomerDetailsInput!): UpdateCustomerDetailsPayload!
  updateSupplierAddress(input: UpdateSupplierAddressInput!): UpdateSupplierAddressPayload!
  updateSupplierDetails(input: UpdateSupplierDetailsInput!): UpdateSupplierDetailsPayload!
}

"""
The node interface is implemented by entities that have a global unique identifier.
"""
interface Node {
  id: ID!
}

"""Information about pagination in a connection."""
type PageInfo {
  """When paginating forwards, the cursor to continue."""
  endCursor: String
  """
  Indicates whether more edges exist following the set defined by the clients arguments.
  """
  hasNextPage: Boolean!
  """
  Indicates whether more edges exist prior the set defined by the clients arguments.
  """
  hasPreviousPage: Boolean!
  """When paginating backwards, the cursor to continue."""
  startCursor: String
}

type Query {
  articleById(id: ID!): Article
  articles(
    """Returns the elements in the list that come after the specified cursor."""
    after: String
    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String
    """Returns the first _n_ elements from the list."""
    first: Int
    """Returns the last _n_ elements from the list."""
    last: Int
    order: [ArticleSortInput!]
    where: ArticleFilterInput
  ): ArticlesConnection
  customerById(id: ID!): Customer
  customers(
    """Returns the elements in the list that come after the specified cursor."""
    after: String
    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String
    """Returns the first _n_ elements from the list."""
    first: Int
    """Returns the last _n_ elements from the list."""
    last: Int
    order: [CustomerSortInput!]
    where: CustomerFilterInput
  ): CustomersConnection
  """Fetches an object given its ID."""
  node(
    """ID of the object."""
    id: ID!
  ): Node
  supplierById(id: ID!): Supplier
  suppliers(
    """Returns the elements in the list that come after the specified cursor."""
    after: String
    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String
    """Returns the first _n_ elements from the list."""
    first: Int
    """Returns the last _n_ elements from the list."""
    last: Int
    order: [SupplierSortInput!]
    where: SupplierFilterInput
  ): SuppliersConnection
}

union RegisterArticleError = ApplicationError

input RegisterArticleInput {
  code: String!
  description: String
  name: String!
  price: Decimal!
  sellingUnit: Decimal!
  suppliers: [IdInputOfGuidInput!]
}

type RegisterArticlePayload {
  article: Article
  errors: [RegisterArticleError!]
}

union RegisterCustomerError = ApplicationError

input RegisterCustomerInput {
  addresses: [CreateAddressInput!]
  code: String!
  email: String
  name: String!
  website: String
}

type RegisterCustomerPayload {
  customer: Customer
  errors: [RegisterCustomerError!]
}

union RegisterSupplierError = ApplicationError

input RegisterSupplierInput {
  addresses: [CreateAddressInput!]
  code: String!
  email: String
  name: String!
  website: String
}

type RegisterSupplierPayload {
  errors: [RegisterSupplierError!]
  supplier: Supplier
}

union RemoveAddressFromCustomerError = ApplicationError

input RemoveAddressFromCustomerInput {
  addressId: ID!
  customerId: ID!
}

type RemoveAddressFromCustomerPayload {
  customer: Customer
  errors: [RemoveAddressFromCustomerError!]
}

union RemoveAddressFromSupplierError = ApplicationError

input RemoveAddressFromSupplierInput {
  addressId: ID!
  supplierId: ID!
}

type RemoveAddressFromSupplierPayload {
  errors: [RemoveAddressFromSupplierError!]
  supplier: Supplier
}

enum SortEnumType {
  ASC
  DESC
}

input StringOperationFilterInput {
  and: [StringOperationFilterInput!]
  contains: String
  endsWith: String
  eq: String
  in: [String]
  ncontains: String
  nendsWith: String
  neq: String
  nin: [String]
  nstartsWith: String
  or: [StringOperationFilterInput!]
  startsWith: String
}

type Subscription {
  onArticleRegistered: Article!
  onCustomerRegistered: Customer!
  onDeactivateCustomer: UUID!
  onDeactivateSupplier: UUID!
  onDiscontinueArticle: Int!
  onSupplierLinkedToArticle: Article!
  onSupplierRegistered: Supplier!
  onSupplierUnlinkedFromArticle: Article!
  onUpdateArticleDetails: Article!
  onUpdateCustomerDetails: Customer!
  onUpdateSupplierDetails: Supplier!
}

type Supplier implements Node {
  active: Boolean!
  addresses(order: [AddressSortInput!]): [Address!]!
  code: String!
  dateTimeDeactivated: DateTime
  email: String
  id: ID!
  name: String!
  website: String
}

input SupplierFilterInput {
  active: BooleanOperationFilterInput
  and: [SupplierFilterInput!]
  code: StringOperationFilterInput
  dateTimeDeactivated: DateTimeOperationFilterInput
  email: StringOperationFilterInput
  id: UuidOperationFilterInput
  name: StringOperationFilterInput
  or: [SupplierFilterInput!]
  website: StringOperationFilterInput
}

input SupplierSortInput {
  active: SortEnumType
  code: SortEnumType
  dateTimeDeactivated: SortEnumType
  email: SortEnumType
  id: SortEnumType
  name: SortEnumType
  website: SortEnumType
}

"""A connection to a list of items."""
type SuppliersConnection {
  """A list of edges."""
  edges: [SuppliersEdge!]
  """A flattened list of the nodes."""
  nodes: [Supplier!]
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """Identifies the total count of items in the connection."""
  totalCount: Int!
}

"""An edge in a connection."""
type SuppliersEdge {
  """A cursor for use in pagination."""
  cursor: String!
  """The item at the end of the edge."""
  node: Supplier!
}

scalar UUID

union UnlinkFromSupplierError = ApplicationError

input UnlinkFromSupplierInput {
  articleId: ID!
  supplierId: ID!
}

type UnlinkFromSupplierPayload {
  article: Article
  errors: [UnlinkFromSupplierError!]
}

input UpdateAddressInput {
  city: String
  countryCode: String
  id: ID!
  number: String
  state: String
  street: String
  zipCode: String
}

union UpdateArticleDetailsError = ApplicationError

input UpdateArticleDetailsInput {
  addedSuppliers: [IdInputOfGuidInput!]
  code: String!
  description: String
  id: ID!
  name: String!
  price: Decimal!
  removedSuppliers: [IdInputOfGuidInput!]
  sellingUnit: Decimal!
}

type UpdateArticleDetailsPayload {
  article: Article
  errors: [UpdateArticleDetailsError!]
}

union UpdateCustomerAddressError = ApplicationError

input UpdateCustomerAddressInput {
  address: UpdateAddressInput!
  customerId: ID!
}

type UpdateCustomerAddressPayload {
  customer: Customer
  errors: [UpdateCustomerAddressError!]
}

union UpdateCustomerDetailsError = ApplicationError

input UpdateCustomerDetailsInput {
  addedAddresses: [CreateAddressInput!]
  code: String!
  email: String
  id: ID!
  name: String!
  removedAddresses: [IdInputOfGuidInput!]
  updatedAddresses: [UpdateAddressInput!]
  website: String
}

type UpdateCustomerDetailsPayload {
  customer: Customer
  errors: [UpdateCustomerDetailsError!]
}

union UpdateSupplierAddressError = ApplicationError

input UpdateSupplierAddressInput {
  address: UpdateAddressInput!
  supplierId: ID!
}

type UpdateSupplierAddressPayload {
  errors: [UpdateSupplierAddressError!]
  supplier: Supplier
}

union UpdateSupplierDetailsError = ApplicationError

input UpdateSupplierDetailsInput {
  addedAddresses: [CreateAddressInput!]
  code: String!
  email: String
  id: ID!
  name: String!
  removedAddresses: [IdInputOfGuidInput!]
  updatedAddresses: [UpdateAddressInput!]
  website: String
}

type UpdateSupplierDetailsPayload {
  errors: [UpdateSupplierDetailsError!]
  supplier: Supplier
}

input UuidOperationFilterInput {
  eq: UUID
  gt: UUID
  gte: UUID
  in: [UUID]
  lt: UUID
  lte: UUID
  neq: UUID
  ngt: UUID
  ngte: UUID
  nin: [UUID]
  nlt: UUID
  nlte: UUID
}